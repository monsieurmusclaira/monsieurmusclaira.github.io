// node_modules/delegate-it/delegate.js
var ledger = /* @__PURE__ */ new WeakMap();
function editLedger(wanted, baseElement, callback, setup) {
  if (!wanted && !ledger.has(baseElement)) {
    return false;
  }
  const elementMap = ledger.get(baseElement) ?? /* @__PURE__ */ new WeakMap();
  ledger.set(baseElement, elementMap);
  const setups = elementMap.get(callback) ?? /* @__PURE__ */ new Set();
  elementMap.set(callback, setups);
  const existed = setups.has(setup);
  if (wanted) {
    setups.add(setup);
  } else {
    setups.delete(setup);
  }
  return existed && wanted;
}
function safeClosest(event, selector) {
  let target = event.target;
  if (target instanceof Text) {
    target = target.parentElement;
  }
  if (target instanceof Element && event.currentTarget instanceof Element) {
    const closest = target.closest(selector);
    if (closest && event.currentTarget.contains(closest)) {
      return closest;
    }
  }
}
function delegate(selector, type, callback, options = {}) {
  const { signal, base = document } = options;
  if (signal == null ? void 0 : signal.aborted) {
    return;
  }
  const { once, ...nativeListenerOptions } = options;
  const baseElement = base instanceof Document ? base.documentElement : base;
  const capture = Boolean(typeof options === "object" ? options.capture : options);
  const listenerFn = (event) => {
    const delegateTarget = safeClosest(event, selector);
    if (delegateTarget) {
      const delegateEvent = Object.assign(event, { delegateTarget });
      callback.call(baseElement, delegateEvent);
      if (once) {
        baseElement.removeEventListener(type, listenerFn, nativeListenerOptions);
        editLedger(false, baseElement, callback, setup);
      }
    }
  };
  const setup = JSON.stringify({ selector, type, capture });
  const isAlreadyListening = editLedger(true, baseElement, callback, setup);
  if (!isAlreadyListening) {
    baseElement.addEventListener(type, listenerFn, nativeListenerOptions);
  }
  signal == null ? void 0 : signal.addEventListener("abort", () => {
    editLedger(false, baseElement, callback, setup);
  });
}
var delegate_default = delegate;

// node_modules/swup/dist/Swup.module.js
var e = (t, e2) => String(t).toLowerCase().replace(/[\s/_.]+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+|-+$/g, "") || e2 || "";
var n = function(t) {
  let { hash: e2 } = void 0 === t ? {} : t;
  return location.pathname + location.search + (e2 ? location.hash : "");
};
var i = function(t, e2) {
  void 0 === e2 && (e2 = {});
  const i2 = { url: t = t || n({ hash: true }), random: Math.random(), source: "swup", ...e2 };
  history.pushState(i2, "", t);
};
var s = function(t, e2) {
  void 0 === t && (t = null), void 0 === e2 && (e2 = {}), t = t || n({ hash: true });
  const i2 = { ...history.state, url: t, random: Math.random(), source: "swup", ...e2 };
  history.replaceState(i2, "", t);
};
var o = (e2, n2, i2, s2) => {
  const o2 = new AbortController();
  return delegate_default(e2, n2, i2, s2), { destroy: () => o2.abort() };
};
var r = function(t, e2) {
  return void 0 === e2 && (e2 = document), e2.querySelector(t);
};
var a = function(t, e2) {
  return void 0 === e2 && (e2 = document), Array.from(e2.querySelectorAll(t));
};
var l = (t) => {
  requestAnimationFrame(() => {
    requestAnimationFrame(() => {
      t();
    });
  });
};
var c = (t) => window.CSS && window.CSS.escape ? CSS.escape(t) : t;
var u = (t) => 1e3 * Number(t.slice(0, -1).replace(",", "."));
var h = (t, e2) => {
  var _a, _b;
  let n2 = document.createElement("html");
  n2.innerHTML = t;
  let i2 = [];
  e2.forEach((t2) => {
    if (null == r(t2, n2))
      return console.warn(`[swup] Container ${t2} not found on page.`), null;
    a(t2).length !== a(t2, n2).length && console.warn("[swup] Mismatched number of containers found on new page."), a(t2).forEach((e3, s3) => {
      a(t2, n2)[s3].setAttribute("data-swup", String(i2.length)), i2.push(a(t2, n2)[s3].outerHTML);
    });
  });
  const s2 = ((_a = r("title", n2)) == null ? void 0 : _a.innerText) || "", o2 = (_b = r("body", n2)) == null ? void 0 : _b.className;
  return n2.innerHTML = "", n2 = null, { title: s2, pageClass: o2, blocks: i2, originalContent: t };
};
var d = (t, e2) => {
  const n2 = { url: window.location.pathname + window.location.search, method: "GET", data: null, headers: {} }, { url: i2, method: s2, headers: o2, data: r2 } = { ...n2, ...t }, a2 = new XMLHttpRequest();
  return a2.onreadystatechange = function() {
    4 === a2.readyState && e2(a2);
  }, a2.open(s2, i2, true), Object.entries(o2).forEach((t2) => {
    let [e3, n3] = t2;
    a2.setRequestHeader(e3, n3);
  }), a2.send(r2), a2;
};
var p = class extends URL {
  constructor(t, e2) {
    void 0 === e2 && (e2 = document.baseURI), super(t.toString(), e2);
  }
  get url() {
    return this.pathname + this.search;
  }
  static fromElement(t) {
    const e2 = t.getAttribute("href") || t.getAttribute("xlink:href");
    return new p(e2);
  }
  static fromUrl(t) {
    return new p(t);
  }
};
var g = (t, e2) => {
  let n2 = 0;
  e2.forEach((e3) => {
    null == r(e3, t) ? console.warn(`[swup] Container ${e3} not found on page.`) : a(e3).forEach((i2, s2) => {
      a(e3, t)[s2].setAttribute("data-swup", String(n2)), n2++;
    });
  });
};
var m = (t) => /^to-/.test(t) || ["is-changing", "is-rendering", "is-popstate"].includes(t);
var f = () => {
  const t = document.documentElement.className.split(" ").filter(m);
  document.documentElement.classList.remove(...t);
};
var v = class {
  constructor(t) {
    this.pages = {}, this.last = null, this.swup = void 0, this.swup = t;
  }
  getCacheUrl(t) {
    return this.swup.resolveUrl(p.fromUrl(t).url);
  }
  cacheUrl(t) {
    t.url = this.getCacheUrl(t.url), t.url in this.pages == 0 && (this.pages[t.url] = t), t.responseURL = this.getCacheUrl(t.responseURL), this.last = this.pages[t.url], this.swup.log(`Cache (${Object.keys(this.pages).length})`, this.pages);
  }
  getPage(t) {
    return t = this.getCacheUrl(t), this.pages[t];
  }
  getCurrentPage() {
    return this.getPage(n());
  }
  exists(t) {
    return (t = this.getCacheUrl(t)) in this.pages;
  }
  empty() {
    this.pages = {}, this.last = null, this.swup.log("Cache cleared");
  }
  remove(t) {
    delete this.pages[this.getCacheUrl(t)];
  }
};
var w = function(t) {
  let { event: e2, skipTransition: n2 } = void 0 === t ? {} : t;
  if (n2)
    return this.triggerEvent("transitionEnd", e2), this.cleanupAnimationClasses(), [Promise.resolve()];
  l(() => {
    this.triggerEvent("animationInStart"), document.documentElement.classList.remove("is-animating");
  });
  const i2 = this.getAnimationPromises("in");
  return Promise.all(i2).then(() => {
    this.triggerEvent("animationInDone"), this.triggerEvent("transitionEnd", e2), this.cleanupAnimationClasses();
  }), i2;
};
var E = (t) => {
  if (t && "#" === t.charAt(0) && (t = t.substring(1)), !t)
    return null;
  const e2 = decodeURIComponent(t);
  return document.getElementById(t) || document.getElementById(e2) || r(`a[name='${c(t)}']`) || r(`a[name='${c(e2)}']`);
};
var P = "transition";
var S = "transitionend";
var b = "animation";
var U = "animationend";
function k(t) {
  const e2 = this.options.animationSelector;
  if (false === e2)
    return [Promise.resolve()];
  const n2 = a(e2, document.body);
  return n2.length ? n2.map((t2) => function(t3, e3, n3) {
    void 0 === n3 && (n3 = null);
    const { type: i2, timeout: s2, propCount: o2 } = function(t4, e4) {
      void 0 === e4 && (e4 = null);
      const n4 = window.getComputedStyle(t4), i3 = `${P}Duration`, s3 = `${b}Delay`, o3 = `${b}Duration`, r2 = n4[`${P}Delay`].split(", "), a2 = (n4[i3] || "").split(", "), l2 = y(r2, a2), c2 = (n4[s3] || "").split(", "), u2 = (n4[o3] || "").split(", "), h2 = y(c2, u2);
      let d2 = "", p2 = 0, g2 = 0;
      return "transition" === e4 ? l2 > 0 && (d2 = "transition", p2 = l2, g2 = a2.length) : "animation" === e4 ? h2 > 0 && (d2 = "animation", p2 = h2, g2 = u2.length) : (p2 = Math.max(l2, h2), d2 = p2 > 0 ? l2 > h2 ? "transition" : "animation" : null, g2 = d2 ? "transition" === d2 ? a2.length : u2.length : 0), { type: d2, timeout: p2, propCount: g2 };
    }(t3, n3);
    return i2 && s2 ? new Promise((e4) => {
      const n4 = "transition" === i2 ? S : U, r2 = performance.now();
      let a2 = 0;
      const l2 = () => {
        t3.removeEventListener(n4, c2), e4();
      }, c2 = (e5) => {
        if (e5.target === t3) {
          if (!((t4) => [S, U].includes(t4.type))(e5))
            throw new Error("Not a transition or animation event.");
          (performance.now() - r2) / 1e3 < e5.elapsedTime || ++a2 >= o2 && l2();
        }
      };
      setTimeout(() => {
        a2 < o2 && l2();
      }, s2 + 1), t3.addEventListener(n4, c2);
    }) : (console.warn(`[swup] No CSS transition duration defined for element of selector ${e3}`), Promise.resolve());
  }(t2, e2)) : (console.warn(`[swup] No animated elements found by selector ${e2}`), [Promise.resolve()]);
}
function y(t, e2) {
  for (; t.length < e2.length; )
    t = t.concat(t);
  return Math.max(...e2.map((e3, n2) => u(e3) + u(t[n2])));
}
void 0 === window.ontransitionend && void 0 !== window.onwebkittransitionend && (P = "WebkitTransition", S = "webkitTransitionEnd"), void 0 === window.onanimationend && void 0 !== window.onwebkitanimationend && (b = "WebkitAnimation", U = "webkitAnimationEnd");
var L = function(t) {
  const e2 = h(t.responseText, this.options.containers);
  return e2 ? { ...e2, responseURL: t.responseURL || window.location.href } : (console.warn("[swup] Received page is invalid."), null);
};
function C(t) {
  const e2 = this.options.requestHeaders, { url: n2 } = t;
  return this.cache.exists(n2) ? (this.triggerEvent("pageRetrievedFromCache"), Promise.resolve(this.cache.getPage(n2))) : new Promise((i2, s2) => {
    d({ ...t, headers: e2 }, (t2) => {
      if (500 === t2.status)
        return this.triggerEvent("serverError"), void s2(n2);
      const e3 = this.getPageData(t2);
      if (!e3 || !e3.blocks.length)
        return void s2(n2);
      const o2 = { ...e3, url: n2 };
      this.cache.cacheUrl(o2), this.triggerEvent("pageLoaded"), i2(o2);
    });
  });
}
var T = function(t) {
  let { event: e2, skipTransition: n2 } = void 0 === t ? {} : t;
  const i2 = e2 instanceof PopStateEvent;
  if (n2)
    return this.triggerEvent("animationSkipped"), [Promise.resolve()];
  this.triggerEvent("animationOutStart"), document.documentElement.classList.add("is-changing", "is-leaving", "is-animating"), i2 && document.documentElement.classList.add("is-popstate");
  const s2 = this.getAnimationPromises("out");
  return Promise.all(s2).then(() => {
    this.triggerEvent("animationOutDone");
  }), s2;
};
function H(t) {
  const { url: e2 } = t;
  this.shouldIgnoreVisit(e2) ? window.location.href = e2 : this.performPageLoad(t);
}
function R(t) {
  const { url: s2, event: o2, customTransition: r2 } = t ?? {}, a2 = o2 instanceof PopStateEvent, l2 = this.shouldSkipTransition({ url: s2, event: o2 });
  this.triggerEvent("transitionStart", o2), this.updateTransition(n(), s2, r2), null != r2 && document.documentElement.classList.add(`to-${e(r2)}`);
  const c2 = this.leavePage({ event: o2, skipTransition: l2 }), u2 = this.fetchPage(t);
  a2 || i(s2 + (this.scrollToElement || "")), this.currentPageUrl = n(), Promise.all([u2, ...c2]).then((t2) => {
    let [e2] = t2;
    this.renderPage(e2, { event: o2, skipTransition: l2 });
  }).catch((t2) => {
    void 0 !== t2 && (this.options.skipPopStateHandling = () => (window.location = t2, true), history.go(-1));
  });
}
var A = function(t) {
  let { blocks: e2, title: n2 } = t;
  return e2.forEach((t2, e3) => {
    document.body.querySelector(`[data-swup="${e3}"]`).outerHTML = t2;
  }), document.title = n2, Promise.resolve();
};
function $(t, e2) {
  const n2 = this._handlers[t];
  n2 ? n2.push(e2) : console.warn(`Unsupported event ${t}.`);
}
function _(t, e2) {
  if (t && e2) {
    const n2 = this._handlers[t];
    n2.includes(e2) ? this._handlers[t] = n2.filter((t2) => t2 !== e2) : console.warn(`Handler for event '${t}' not found.`);
  } else
    t ? this._handlers[t] = [] : Object.keys(this._handlers).forEach((t2) => {
      this._handlers[t2] = [];
    });
}
function I(t, e2) {
  this._handlers[t].forEach((t2) => {
    try {
      t2(e2);
    } catch (t3) {
      console.error(t3);
    }
  });
  const n2 = new CustomEvent(`swup:${t}`, { detail: t });
  document.dispatchEvent(n2);
}
var x = function(t) {
  if (t == null ? void 0 : t.isSwupPlugin) {
    if (t.swup = this, !t._checkRequirements || t._checkRequirements())
      return t._beforeMount && t._beforeMount(), t.mount(), this.plugins.push(t), this.plugins;
  } else
    console.error("Not a swup plugin instance", t);
};
function q(t) {
  const e2 = this.findPlugin(t);
  if (e2)
    return e2.unmount(), e2._afterUnmount && e2._afterUnmount(), this.plugins = this.plugins.filter((t2) => t2 !== e2), this.plugins;
  console.error("No such plugin", e2);
}
function D(t) {
  return this.plugins.find((e2) => e2 === t || e2.name === t);
}
var M = function(t, e2) {
  let { event: i2, skipTransition: o2 } = void 0 === e2 ? {} : e2;
  if (document.documentElement.classList.remove("is-leaving"), !this.isSameResolvedUrl(n(), t.url))
    return;
  const { url: r2 } = p.fromUrl(t.responseURL);
  this.isSameResolvedUrl(n(), r2) || (this.cache.cacheUrl({ ...t, url: r2 }), this.currentPageUrl = n(), s(r2)), o2 || document.documentElement.classList.add("is-rendering"), this.triggerEvent("willReplaceContent", i2), this.replaceContent(t).then(() => {
    this.triggerEvent("contentReplaced", i2), this.triggerEvent("pageView", i2), this.options.cache || this.cache.empty(), this.enterPage({ event: i2, skipTransition: o2 }), this.scrollToElement = null;
  });
};
function N(t, e2, n2) {
  this.transition = { from: t, to: e2, custom: n2 };
}
function W(t) {
  let { event: e2 } = t;
  return !(!(e2 instanceof PopStateEvent) || this.options.animateHistoryBrowsing);
}
var O = class {
  constructor(t) {
    void 0 === t && (t = {}), this.version = "3.0.7", this._handlers = { animationInDone: [], animationInStart: [], animationOutDone: [], animationOutStart: [], animationSkipped: [], clickLink: [], contentReplaced: [], disabled: [], enabled: [], openPageInNewTab: [], pageLoaded: [], pageRetrievedFromCache: [], pageView: [], popState: [], samePage: [], samePageWithHash: [], serverError: [], transitionStart: [], transitionEnd: [], willReplaceContent: [] }, this.scrollToElement = null, this.options = void 0, this.plugins = [], this.transition = {}, this.cache = void 0, this.currentPageUrl = n(), this.delegatedListeners = {}, this.boundPopStateHandler = void 0, this.loadPage = H, this.performPageLoad = R, this.leavePage = T, this.renderPage = M, this.replaceContent = A, this.enterPage = w, this.triggerEvent = I, this.delegateEvent = o, this.on = $, this.off = _, this.updateTransition = N, this.shouldSkipTransition = W, this.getAnimationPromises = k, this.getPageData = L, this.fetchPage = C, this.getAnchorElement = E, this.log = () => {
    }, this.use = x, this.unuse = q, this.findPlugin = D, this.getCurrentUrl = n, this.cleanupAnimationClasses = f, this.defaults = { animateHistoryBrowsing: false, animationSelector: '[class*="transition-"]', cache: true, containers: ["#swup"], ignoreVisit: function(t2, e2) {
      let { el: n2 } = void 0 === e2 ? {} : e2;
      return !!(n2 == null ? void 0 : n2.closest("[data-no-swup]"));
    }, linkSelector: "a[href]", plugins: [], resolveUrl: (t2) => t2, requestHeaders: { "X-Requested-With": "swup", Accept: "text/html, application/xhtml+xml" }, skipPopStateHandling: (t2) => {
      var _a;
      return "swup" !== ((_a = t2.state) == null ? void 0 : _a.source);
    } }, this.options = { ...this.defaults, ...t }, this.boundPopStateHandler = this.popStateHandler.bind(this), this.cache = new v(this), this.enable();
  }
  enable() {
    "undefined" != typeof Promise ? (this.delegatedListeners.click = o(this.options.linkSelector, "click", this.linkClickHandler.bind(this)), window.addEventListener("popstate", this.boundPopStateHandler), g(document.documentElement, this.options.containers), this.options.plugins.forEach((t) => this.use(t)), s(), this.triggerEvent("enabled"), document.documentElement.classList.add("swup-enabled"), this.triggerEvent("pageView")) : console.warn("Promise is not supported");
  }
  destroy() {
    this.delegatedListeners.click.destroy(), window.removeEventListener("popstate", this.boundPopStateHandler), this.cache.empty(), this.options.plugins.forEach((t) => {
      this.unuse(t);
    }), a("[data-swup]").forEach((t) => {
      t.removeAttribute("data-swup");
    }), this.off(), this.triggerEvent("disabled"), document.documentElement.classList.remove("swup-enabled");
  }
  shouldIgnoreVisit(t, e2) {
    let { el: n2, event: i2 } = void 0 === e2 ? {} : e2;
    const { origin: s2, url: o2, hash: r2 } = p.fromUrl(t);
    return s2 !== window.location.origin || !(!n2 || !this.triggerWillOpenNewWindow(n2)) || !!this.options.ignoreVisit(o2 + r2, { el: n2, event: i2 });
  }
  linkClickHandler(t) {
    const e2 = t.delegateTarget, { href: i2, url: s2, hash: o2 } = p.fromElement(e2);
    if (this.shouldIgnoreVisit(i2, { el: e2, event: t }))
      return;
    if (t.metaKey || t.ctrlKey || t.shiftKey || t.altKey)
      return void this.triggerEvent("openPageInNewTab", t);
    if (0 !== t.button)
      return;
    if (this.triggerEvent("clickLink", t), t.preventDefault(), !s2 || s2 === n())
      return void this.handleLinkToSamePage(s2, o2, t);
    if (this.isSameResolvedUrl(s2, n()))
      return;
    this.scrollToElement = o2 || null;
    const r2 = e2.getAttribute("data-swup-transition") || void 0;
    this.performPageLoad({ url: s2, customTransition: r2 });
  }
  handleLinkToSamePage(t, e2, n2) {
    if (e2) {
      if (this.triggerEvent("samePageWithHash", n2), !E(e2))
        return console.warn(`Element for offset not found (#${e2})`);
      s(t + e2);
    } else
      this.triggerEvent("samePage", n2);
  }
  triggerWillOpenNewWindow(t) {
    return !!t.matches('[download], [target="_blank"]');
  }
  popStateHandler(t) {
    var _a;
    if (this.options.skipPopStateHandling(t))
      return;
    if (this.isSameResolvedUrl(n(), this.currentPageUrl))
      return;
    const e2 = ((_a = t.state) == null ? void 0 : _a.url) ?? location.href;
    if (this.shouldIgnoreVisit(e2, { event: t }))
      return;
    const { url: i2, hash: s2 } = p.fromUrl(e2);
    s2 ? this.scrollToElement = s2 : t.preventDefault(), this.triggerEvent("popState", t), this.options.animateHistoryBrowsing || (document.documentElement.classList.remove("is-animating"), f()), this.performPageLoad({ url: i2, event: t });
  }
  resolveUrl(t) {
    if ("function" != typeof this.options.resolveUrl)
      return console.warn("[swup] options.resolveUrl expects a callback function."), t;
    const e2 = this.options.resolveUrl(t);
    return e2 && "string" == typeof e2 ? e2.startsWith("//") || e2.startsWith("http") ? (console.warn("[swup] options.resolveUrl needs to return a relative url"), t) : e2 : (console.warn("[swup] options.resolveUrl needs to return a url"), t);
  }
  isSameResolvedUrl(t, e2) {
    return this.resolveUrl(t) === this.resolveUrl(e2);
  }
};
export {
  p as Location,
  e as classify,
  f as cleanupAnimationClasses,
  i as createHistoryRecord,
  O as default,
  o as delegateEvent,
  c as escapeCssIdentifier,
  d as fetch,
  n as getCurrentUrl,
  h as getDataFromHtml,
  g as markSwupElements,
  l as nextTick,
  r as query,
  a as queryAll,
  u as toMs,
  s as updateHistoryRecord
};
//# sourceMappingURL=swup.js.map
